package main

/*
给你一个 n 个节点的无向无根树，节点编号从 0 到 n - 1
给你整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间有一条边
再给你一个长度为 n 的数组 coins ，其中 coins[i] 可能为 0 也可能为 1 ，1 表示节点 i 处有一个金币
一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次:
收集距离当前节点距离为 2 以内的所有金币，或者
移动到树中一个相邻节点
你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数
如果你多次经过一条边，每一次经过都会给答案加一
*/

func collectTheCoins(coins []int, edges [][]int) int {
	n := len(coins)
	g := make([][]int, n)
	degree := make([]int, n)
	for _, edge := range edges {
		x, y := edge[0], edge[1]
		g[x] = append(g[x], y)
		g[y] = append(g[y], x)
		degree[x]++
		degree[y]++
	}

	rest := n
	// 删除树中所有无金币的叶子节点，直到树中所有的叶子节点都是含有金币的
	q := []int{}
	for i := 0; i < n; i++ {
		if degree[i] == 1 && coins[i] == 0 {
			q = append(q, i)
		}
	}
	for len(q) > 0 {
		u := q[0]
		q = q[1:]
		degree[u]--
		rest--
		for _, v := range g[u] {
			degree[v]--
			if degree[v] == 1 && coins[v] == 0 {
				q = append(q, v)
			}
		}
	}

	// 删除树中所有的叶子节点, 连续删除2次
	for j := 0; j < 2; j++ {
		q := []int{}
		for i := 0; i < n; i++ {
			if degree[i] == 1 {
				q = append(q, i)
			}
		}
		for len(q) > 0 {
			u := q[0]
			q = q[1:]
			degree[u]--
			rest--
			for _, v := range g[u] {
				degree[v]--
			}
		}
	}

	if rest == 0 {
		return 0
	}
	return (rest - 1) * 2
}

/*
对于给定无根树中度数为 111 的节点，我们称其为「叶节点」。可以发现，对于每一个「叶节点」lll，如果 lll 上没有金币，那么我们就没有必要走到 lll。这是因为对于 lll 唯一相邻的那个节点 l′l'l
它可以收集到在 lll 可以收集到的所有金币，那么：
如果我们从 lll 开始出发，那么可以改成从 l′l'l
开始出发，经过的边数一定减少；
如果我们不从 lll 开始出发，那么到达 l′l'l
之后不必再走向 lll，经过的边数一定减少。
因此，我们可以不断地移除给定无根树中没有金币的「叶节点」。当某个「叶节点」被移除后，它唯一相邻的那条边也需要被移除，这样可能会有新的节点变为「叶节点」。我们不断迭代地重复这个过程，直到所有的「叶节点」上都有金币为止。
这一步可以使用基于广度优先搜索的拓扑排序解决。我们首先将所有「叶节点」加入队列中，随后不断从队列中取出节点，将它标记为删除，并判断其唯一相邻的节点是否变为「叶节点」。如果是，就将相邻的节点也加入队列中。
当所有的「叶节点」上都有金币时，我们应该如何解决给定的问题呢？我们可以先思考，如果操作变为「收集距离当前节点距离为 000 以内的所有金币」该如何解决。当距离为 000 时，我们必须要走到对应的节点上才能收集金币，而每个「叶节点」上都有金币，因此我们必须遍历到所有的「叶节点」，这也意味着我们遍历了整颗树。
从任一节点出发，遍历整颗树并返回原节点，会经过树上的每条边一次，而树的边数等于点数减一，因此答案为 2(n′−1)2(n'-1)2(n−1)，其中 n′n'n
时经过上文移除后，无根树中节点的数量
如果操作变为「收集距离当前节点距离为 111 以内的所有金币」呢？我们可以进一步思考得到：当我们即将遍历到「叶节点」时，可以直接返回，因为此时我们与「叶节点」的距离为 111，可以直接收集到金币，不需要走到「叶节点」。因此，我们遍历的范围，就是将树中所有叶节点以及它们唯一相邻的那条边移除后的新树。在新树中的金币可以通过遍历获得到，而不在新树中的金币会在遍历到与其距离为 111 的某个节点时获取到。
因此，当操作变为「收集距离当前节点距离为 222 以内的所有金币」时，我们的方法仍然是类似的，我们只需要将新树中所有的「叶节点」以及它们唯一相邻的那条边移除，得到的新新树就是需要遍历的范围。
这一步同样可以使用基于广度优先搜索的拓扑排序解决。我们进行 222 次如下的操作：首先将所有「叶节点」加入初始队列中，随后不断从初始队列中取出节点，将它标记为删除。
细节
如果新新树中没有任何节点，说明在初始的无根树中，存在一个节点可以直接获取到所有金币，答案为 000，否则答案为 2×(2\times(2×( 新新树中的节点数量 −1)-1)−1)
*/
